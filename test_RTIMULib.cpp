#include <iostream>
#include "mraa.h"
#include "RTIMULib.h"
#include "RTMath.h"

#define PI 3.141593
#define R2D 57.2957732
using namespace std;

int main() {

	int sampleCount = 0;
	int sampleRate = 0;
	uint64_t rateTimer;
	uint64_t displayTimer;
	uint64_t now;

	//  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
	//  Or, you can create the .ini in some other directory by using:
	//      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
	//  where <directory path> is the path to where the .ini file is to be loaded/saved

	RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

	RTIMU *imu = RTIMU::createIMU(settings);

	if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
		printf("No IMU found\n");
		exit(1);
	}

	//  This is an opportunity to manually override any settings before the call IMUInit

	//  set up IMU

	imu->IMUInit();

	//  this is a convenient place to change fusion parameters

	imu->setSlerpPower(0.02);
	imu->setGyroEnable(true);
	imu->setAccelEnable(true);
	imu->setCompassEnable(true);

	//  set up for rate timer



  /* Code in this loop will run repeatedly
   */
  for (;;) {

	  if (imu->IMURead()) {
		  RTIMU_DATA imuData = imu->getIMUData() ;
		  printf("Sensors Valid? : %d %d %d\n", imuData.accelValid, imuData.compassValid, imuData.gyroValid) ;
		  printf("Fusion Success? : %d \n", imuData.fusionPoseValid) ;
		  RTVector3 curr_pose = imuData.fusionPose ;
		  printf("Roll = %g Pitch = %g Yaw = %g \n", curr_pose.x()*R2D, curr_pose.y()*R2D, curr_pose.z()*R2D ) ;

	  }
	  else
		  printf("No data available") ;
	  usleep(1000000) ;
  }

  return 0;
}
